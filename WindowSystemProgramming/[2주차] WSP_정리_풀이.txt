[ 2주차 윈도우 시스템 프로그래밍 용S TEST ]

1. 프로세스란 무엇이며 프로세스를 구성하는 메모리 구조는 어떻게 되는가?
각각의 구조에 대해 간단하게 설명하시오
-> 프로세스는 실행중인 프로그램을 의미하며, 각 프로세스들의 메모리는 CODE(코드), DATA(전역 변수), HEAP(동적 할당), STACK(지역 변수)로 이루어져있다.


2. A프로세스와 B프로세스가 실행되고 있다면 메모리 구조는 몇개가 생기는가? -> 2개
그리고 프로세스들은 서로가 서로를 알 수 있는 방법이 있는지 추측해보시오. -> 핸들을 통해?

★ 프로세스는 각자만의 메모리 구조를 가지고 있기 때문에 일반적으로는 서로가 서로를 알 수 없다. (쓰레드끼리는 서로 알 수 있다 > 그래서 멀티 프로세스가 아니라 멀티 쓰레드를 쓰는 이유)
하지만 소켓 프로그래밍이나 메일 슬롯과 같은 통로를 마련해주면 알 수 있는 방법이 존재한다.

3. CPU는 하나이며 한 순간에 하나의 프로그램만 실행이 가능하다.
그런데도 우리의 컴퓨터는 어떻게 여러 개의 프로그램이 동시에 실행 가능한 것인지 설명해보시오
-> 멀티 프로세스 구조에서는, 실질적으로 CPU는 하나의 프로그램을 실행하고 있지만, 빠른 속도로 각 프로세스들의 상태를 왔다갔다하며 우리가 보기에는 동시에 실행되는 것처럼 보이는 것이다.
예를 들어, A와 B라는 프로그램을 동시에 실행시키고, A가 먼저 현재 실행중이라고 하면, A가 파일 I/O(입출력 상태)에 돌입하거나 하면, A가 Block상테에 들어가면서 Ready 상태에 있던 B프로그램을 Running하는 방식으로 동시에 실행하는 것 처럼 보이게 한다.


4. A,B,C 3가지의 프로세스가 있다고 가정해보자.
A > B > C 를 하나의 프로세스씩 동기식으로 실행시키는 방식이 있을 것이며 그렇지 않은 다른 방법이 있다. -> Context Switching을 통한 비동기식으로 A,B,C의 상태에 따라 동시에 실행하는 방법이 있다.
우리의 CPU는 이 3가지의 프로세스를 어떠한 과정으로 실행시키는지 간단하게 설명해보시오. 
-> A,B,C의 우선순위가 높은 순서대로 먼저 Running 상태에 들어가고 나머지는 Ready 상태에 있으며, 사용자가 동작을 멈추거나, 파일 I/O와 같은 상태일 때 다음 우선순위의 프로세스를 동작시키고 앞선 프로세스를 Ready 상태로 돌리는
과정을 지속적으로 반복하며 동시에 실행시키는 것처럼 보이게 한다.


5. 프로세스의 상태에서 Ready / Running / Blocked 3가지 상태가 있다. 
각각의 특징을 설명해보시오 
그리고 Ready와 Blocked는 어떤 차이점이 있는지 설명하시오
-> Ready : 실행 대기중인 상태로 언제든지 Running 상태로 돌입할 수 있다.
-> Running : CPU가 현재 우선적으로 실행하고 있는 상태이며, 파일 I/O 같은 상황에 맞닥뜨리게 된다면 Block 상태로 돌입한다.
-> Blocked : 파일 I/O와 같은 일을 진행 중인 상태이며 Ready상태와의 차이로는 곧바로 Running 상태가 될 수 없으며, Blocked 상태를 마치게 된다면 Ready 상태로 진입해야 한다.


6. 컨텍스트 스위칭이 무엇인지 설명하고 이렇게 동작할 수 밖에 없는 이유와 장단점을 한가지씩 말해보시오
-> 컨텍스트 스위칭은, CPU가 프로세스를 동작하며 레지스터들을 실행중인 프로세스의 내용으로 채우고, 다른 프로세스를 동작할 때에는 레지스터를 비워주면서 메모리에 있던 다른 프로세스의 내용을 다시 레지스터로 불러오게 된다.
이와 같은 과정을 Context Switching이라고 하며, 이렇게 동작할 수 밖에 없는 이유는 레지스터의 크기가 크지 않기 때문에 동작중인 프로세스가 바뀌게 된다면 레지스터 안의 내용을 비워 주어야 하기 때문이다.
장점으로는 멀티프로세스, 즉 동시에 여러가지 프로그램을 실행할 수 있다는 점이 있지만, 단점으로는 잦은 Context Switching은 그 과정에서 부하를 초래할 수 있다.

★ 선택지는 컨텍스트 스위칭을 발생시키냐 vs 동기식으로 동작하냐? > 동기식보다는 어쨌든 컨텍스트 스위칭의 부하가 발생하는게 차라리 낫다.
멀티 프로세스 vs 멀티 쓰레드 > 컨텍스트 스위칭 부하가 누가 더 클까? > 프로세스가 여러개의 쓰레드가 모인 단위인데 쓰레드보다는 내용이 훨씬 많다.


7. (프로세스를 생성하는 실질적인 주체는 프로그래머가 아니라 운영체제이며 생성된 프로세스를 관리하는 것도 운영체제의 몫이다)
커널 오브젝트에 대해 설명해보시오.
그리고 커널 오브젝트에 내부 내용은 어떤것이 있을지 추측해서 적어보시오
-> 커널 오브젝트는 프로세스의 관련한 중요 데이터들을 모아놓은 데이터라고 볼 수 있고, 내부에는 사용자가 직접 접근할 수 없는 관련 데이터들이 있을 것이다.

★커널 오브젝트는 프로세스/쓰레드/리소스와 같은 여러가지 데이터들을 내부적으로 관리하는 주체이며 간접적으로만 접근이 가능하다.
이 내부안에는 프로세스나 쓰레드의 우선순위나 상태 정보(Block/Ready/Running)들이 있을것이다.


8. HANDLE에 대해 설명해보시오(조작 방식, 접근 권한, 반환 값 등)
-> 핸들은 각 프로세스들을 구분하기 위한 데이터라고 볼 수 있으며, 프로세스에 종속적이며, 각 프로세스를 구분할 수 있는 정수형태의 반환 값을 가지게 된다.

★HANDLE은 정수 값이며 커널 오브젝트의 고유 ID라고 볼 수 있다. 커널 오브젝트를 구분하기 위한 값이다.


9. Busy Waiting에 대해 설명해보고 이를 탈피하기 위한 방법이 무엇인지 설명해보시오
-> 우선순위에 있는 프로세스가 파일 I/O와 같은 작업에 돌입할 때의 긴 대기상태에 돌입하는 것을 의미하며 Sleep 함수같은 것을 사용해서 이를 탈피할 수 있다. 

★ Busy Waiting이란 어떤 코드의 내용이 너무 오래걸리는 일(for loop 1억번)이라 하나의 프로세스가 CPU를 계속해서 점유해서 다른 프로세스가 실행을 많이 못하는 상태(CPU 점유를 한쪽이 너무 크게 먹은 상태)
Sleep을 사용하게 되면 잠시 CPU가 해당 프로세스에서 하던 일을 멈추고 다른 프로세스로 넘어간다.(다른 프로세스에게 CPU를 점유할 기회를 준다)


10. 프로세스 A 코드에서 프로세스 B의 우선순위를 최상위로 설정해서 생성했다고 가정해보자.
프로세스 A는 실행할 수 있는 기회를 언제 얻는가? 
-> 프로세스 B가 파일 I/O 상태에 돌입할 때, 프로세스 A는 실행할 기회를 얻게 된다.


★I/O 상태 혹은 다른 어떤 이유로든 간에 어떠한 프로세스가 전혀 기회를 얻지 못하는 상황은 거의 나오지 않는다(기아 상태가 발생하는 경우는 드물다)
조금이라도 실행을 될 것이다.


11. 커널 오브젝트는 어디에 종속적인가? 
왜 커널 오브젝트가 ~~~에 종속 되어있다고 말할 수 있는가?
-> 커널 오브젝트는 운영체제에 종속적이다.
왜냐하면, 사용자 혹은 프로세스가 간접적으로 운영체제에 요청을 하여 커널 오브젝트를 통제하는 방식이므로 커널 오브젝트는 운영체제에 종속적이라고 볼 수 있다.


★커널 오브젝트의 소멸 시점에 대해서 운영체제가 다 결정하기 때문


12. 프로세스의 소멸과 커널 오브젝트의 소멸 시점은 어떠한 관계가 있는가?
커널 오브젝트가 소멸되는 시점은 정확하게 언제라고 할 수 있는가?
-> 프로세스와 커널 오브젝트의 소멸 시점은 다르다 라고 볼 수 있으며, 커널 오브젝트가 소멸되는 시점은 참조하는 데이터가 없을 때, usage count가 0일 때 소멸한다.


미쓰...
13. 프로세스의 Handle과 프로세스의 ID는 어떠한 차이점이 있는가?
-> 프로세스의 Handle은 각 프로세스를 구분하기 위한 id와 같은 개념이며, 프로세스의 ID는 프로세스 내부에서 부여하는 ID를 의미한다.


★ HANDLE은 커널 오브젝트를 구분하기 위한 고유 ID값, GetProcessID() 이거는 그냥 말 그대로 프로세스 ID


14. 프로세스를 스케줄링 하는 방식에서 비선점형 OS의 특징과 선점형 OS의 특징에 대해 설명하시오
-> 비선점형 OS는 먼저 실행중인 프로세스가 양보하거나 I/O상태에 돌입하게 되어 다른 프로세스가 동작 기회를 얻는 동기식 방식이라면
선점형 OS는 우선순위에 따라 우선순위가 높은 프로세스를 먼저 실행하는 방식의 비동기식 방식의 OS이다.


★ 비선점형 OS는 무조건 순차적 진행이며 앞에 있는 프로세스가 끝날때까지 다음 프로세스가 실행이 안된다(다만 I/O 상황에서는 잠시 넘겨줄 수는 있지만)
여기서 동기와 비동기의 개념은 머리속에 없애자.... 미쓰....


15. 우리의 컴퓨터에서 사용되고 있는 방식은 선점형 OS의 특징을 가지고 있다.
대표적인 선점형 스케줄링 알고리즘 2가지가 무엇이며 이 알고리즘에 대해 설명해보시오
-> 우선순위 스케줄링, 라운드 로빈의 2가지 방식이 선점형 스케줄링 알고리즘의 대표적인 방식이며, 우선순위 스케줄링은 프로세스의 우선순위에 따라 우선순위가 높은 프로세스를 먼저 실행하는 방식이며,
라운드 로빈 알고리즘은 우선순위가 동등할 시에, 타임 슬라이스를 조절하여 각 프로세스가 원활히 실행될 수 있도록 하는 알고리즘이다. 


16. 타임 슬라이스가 무엇이며 타임 슬라이스를 길게 했을때와 짧게 했을때 각각의 문제점에 대해 설명하시오
-> 타임 슬라이스는 라운드 로빈 알고리즘에서 각 프로세스의 우선순위가 같을 때, 각 프로세스들이 할당받는 시간을 의미하며 타임슬라이스를 너무 짧게 잡으면 잦은 컨텍스트 스위칭으로 인한 부하로 성능의 저하가 일어나며
길게 잡게 되면 속도에 영향을 주게 된다.


17. 스케줄링 알고리즘에 의해서 스케줄링이 진행되는 시점 3가지를 생각해보시오
-> 우선순위가 높을 때, 파일 I/O 작업이 진행될 때, 


★ I/O 작업, 새로운 프로세스의 등장, 타임 슬라이스