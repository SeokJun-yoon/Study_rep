#include <iostream>
using namespace std;

// 포인터 1강

void SetHp(int* hp)
{
	*hp = 100;
}

int main()
{
	int hp = 1;

	// 포인터를 통한 hp의 원본값으로 접근하기 때문에 이제는 SetHp가 제대로 동작하게 된다. 
	SetHp(&hp);


	// 지금까지 사용한 방식
	int number = 1;
	// number라는 이름의 4바이트 정수 타입의 바구니를 만든다.
	// number라는 변수를 스택 메모리에 할당
	// 따라서 스택 메모리에 있는 특정 주소(number 바구니)에 우리가 원하는 값을 넣은 셈
	
	// 즉, number는 메모리에 이름을 붙인 것
	// 기존의 방법이 편리하지만, 원본 수정의 부분에서 한계가 있다.

	// --> 포인터를 사용하는 이유.

	// [ 포인터 사용방식 ]
	// TYPE* 변수이름;
	// - TYPE
	// - *

	// 바구니는 바구니인데, [ 주소를 저장하는 바구니 ]
	// 변수 선언 시에 * 등장하면 -> 포인터 = 주소
	
	// *중요* 참고) 포인터의 크기는 4바이트(32비트) or 8바이트(64비트) 고정 크기
	// 사실상 오늘날 대부분 64비트를 사용하기에 8바이트라고 생각하면 편하다.
	int* ptr = &number;

	// 그렇다면 주소(포인터)를 가지고 무엇을 하는가?
	// 추가 문법 : [주소를 저장하는 바구니]가 가리키는 주소로 가서 무엇인가를 할 것!
	
	// *변수이름 = 값;
	int value1 = *ptr;	// ptr 변수는 number의 주소값을 가지고 있다 -> ptr 앞에 *을 붙임으로서 해당하는 값을 의미, 해당 값을 value1에 대입

	// 강사님 설명 ) *이 붙게 되면 포탈을 타고 순간이동 한다고 비유
	// *이 여러번 등장하니 헷갈리지만, 사용 시점에 따라서 구분해서 기억하기
	// - 변수 선언(주소를 저장하는 바구니) -> 개인적인 생각 : *이 자료형 뒤에 붙게 되면 변수 선언의 역할
	// - 사용할 때(포탈을 타고 순간이동) -> 개인적인 생각 : *이 변수 앞에 붙게 되면 사용의 역할

	*ptr = 2;

	// TYPE은 왜 붙이나?
	// * = 포인터의 의미 = 주소를 저장하는 바구니 = 4/8바이트 고정 크기

	// 주소에 가면 뭐가 있는지?
	// ex) 결혼식 청첩장에 있는 주소 = 예식장 주소
	// ex) 명함에 있는 주소 = 회사 주소
	// * = 포인터 (주소 담는 바구니)

	// 앞에 타입을 쓰는 이유는 결국 해당하는 주소를 타고 갔을 때 무엇이 있는지 알아야 하기 때문이다.
	
	// 그렇다면 타입이 일치하지 않을 경우?
	__int64* ptr2=(__int64*) &number;

	// 위와 같이 타입을 함부로 캐스팅 해주어 원본값을 건드릴 경우, 메모리를 덮어버리거나 하여 예기치 못한 문제가 발생할 수도 있으므로 주의해야 한다.
	
	*ptr2 = 0xAABBCCDDEEFF;


	return 0;

}