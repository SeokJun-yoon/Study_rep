#include <iostream>
using namespace std;

// 2. 포인터 연산

// 1) 주소 연산자 (&)
// 2) 산술 연산자
// 3) 간접 연산자
// 4) 간접 멤버 연산자


struct Player
{
	int hp;	// +0
	int damage;	// +4
};

int main()
{
	int number = 1;

	// 1) 주소 연산자 (&)
	// - 해당 변수의 주소를 알려줌
	// - 더 정확히 말하면 해당 변수 타입(TYPE)에 따라서 TYPE* 반환
	int* pointer = &number;

	// 2) 산술 연산자 (+ -)

	number += 1;	// 1이 증가
	// 위의 연산과 같은 +,- 연산을 포인터에서도 가능

	// int*
	// - * : 포인터 타입, (8바이트) 주소를 담는 바구니
	// - int : 주소를 따라가면 int(4바이트 정수형 바구니)가 있다고 가정

	// [!] 포인터에서 +나 -등 산술 연산으로 1을 더하거나빼면,
	// 정말 '그 숫자'를 더하고 빼라는 의미가 아님.
	// 한번에 TYPE의 크기만큼을 이동하라
	// 다음/이전 바구니로 이동하고 싶다 << [바구니 단위]의 이동으로
	// 즉, 1을 더하면 = 바구니 1개 이동시켜라
	// 3을 더하면 = 바구니 3개 이동시켜라

	//pointer += 1;	// 확인해보면 +1을 했는데 주소값이 4가 증가

	// 디버깅을 해보면, pointer에 들어가 있는 값(number의 주소값)이 4만큼 증가한다는 것을 알 수 있음.
	// 이 4라는 숫자는 현재 포인터 변수인 pointer을 따라가면 int형의 자료가 존재하기 때문임.
	// 만약 int가 아니라 다른 자료형이었다면 4가 증가하지 않을수도 있다.

	// 3) 간접 연산자 (*)
	// - 포탈을 타고 해당 주소로 이동하는 원리
	number = 3;
	*pointer = 3;

	Player player;
	player.hp = 100;
	player.damage = 10;

	Player* playerPtr = &player;
	(*playerPtr).hp = 200;
	(*playerPtr).damage = 200;

	// 4) 간접 멤버 연산자 (->)
	// . 구조체의 특정 멤버를 다룰 때 사용 (어셈블리 언어로 확인해보면 .은 사실상 그냥 덧셈)
	// -> 는 *와 .을 한 번에

	playerPtr->hp = 200;
	playerPtr->damage = 200;

	return 0;
}