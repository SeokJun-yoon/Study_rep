[ 정수/실수/부동소수점 ]

	[자료형]	[크기](표현 가능한 수)
	char			1바이트 (-128~127)
	short			2바이트 (-32768~32767)
	int			4바이트 (-21.4억~21.4억)
	__int64(=long long)	8바이트 (매우 큼)

	unsigned char		1바이트 (0~255)
	unsigned short		2바이트 (0~65535)
	unsigned int		4바이트 (0~42.9억)
	unsigned __int64		8바이트 (0~매우 큼)

* unsigned의 경우 양수 범위 내에서만 표현

- 오버플로우 / 언더플로우
표현할 수 있는 범위보다 '초과'하게 될 경우 오버플로우 ( ex, short a = 32767; a = a + 1; )
표현할 수 있는 범위보다 '미만'일 경우 언더플로우 ( ex, unsigned short b = 0; b = b - 1 ; )


- 부동 소수점(.을 유동적으로 움직여서 표현하는 방법)

실수를 표현할 수 있는 타입
float	4바이트 = 32비트 = 부호(1) 지수(8) 유효숫자(23)
double	8바이트 = 64비트 = 부호(1) 지수(11) 유효숫자(52)


* 핵심은, 프로그래밍에서의 부동소수점은 항상 '근사값'이다.
수가 커질수록 오차 범위 또한 매우 커지므로, 실수를 ==으로 비교하는 것을 지양해야 한다.

